/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "adc.h"
#include "spi.h"
#include "tim.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "EventRecorder.h"
#include "stdlib.h"
#include "arm_math.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

// 烙铁控制状态
typedef enum {
    STATE_HEATING = 0,      // 加热并等待测温间隔
    STATE_PWM_OFF_WAIT_STABLE, // 关闭PWM等待温度稳定
    STATE_MEASURE_TEMP,     // 读取ADC温度
    STATE_CALCULATE_PWM,    // 计算新的PWM
    STATE_UPDATE_DISPLAY    // 更新OLED显示
} T12_Control_State_t;

// 温度校准点 (ADC原始值 -> 实际温度 °C)
// 结构体定义
typedef struct {
    uint16_t adc_val;
    uint16_t temp_c;
} TempCalibrationPoint;

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

// PWM配置
#define PWM_PERIOD          2000 // TIM3 ARR+1, 例如 ARR=1999
#define PWM_MAX_DUTY        (PWM_PERIOD - 1)

// PID 控制参数
#define PID_KP              5.f
#define PID_KI              1.f
#define PID_KD              0.2f
#define PID_INTEGRAL_MAX    1999.0f
#define PID_INTEGRAL_MIN    0.0f
#define PID_DELTA_T         1 // 50ms

#define NUM_CALIBRATION_POINTS (sizeof(temp_calibration_table) / sizeof(TempCalibrationPoint))
#define DEFAULT_TARGET_TEMP 205
#define BANG_BANG_THRESHOLD 20 // 切换PID控制的温差阈值
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */

// 校准数据表
const TempCalibrationPoint temp_calibration_table[] = {
    {0,    25},       // ADC为0时，近似室温
    {1212, 216},      // 校准点1
    {1696, 308},      // 校准点2
    {2181, 390},      // 校准点3
    // 可以根据需要添加更多点
};

arm_pid_instance_f32 PID = {
        .Kp = PID_KP,
        .Ki = PID_KI * PID_DELTA_T,    
        .Kd = PID_KD / PID_DELTA_T 
    };

T12_Control_State_t t12_state = STATE_PWM_OFF_WAIT_STABLE;
uint32_t uWTick = 0;   // 自芯片启动以来的ms
uint32_t last_time_check = 0;   // 上次执行时间
const uint32_t ADC_STABLE_WAIT_MS = 1; // 测温稳定等待时间
const uint32_t CONTROL_PERIOD_MS = 100; // 主控制周期

// 存储编码器计数值（旋转步数）
volatile int16_t rotaryCount = 0; 
// 存储上一次读取到的 A相/CLK 的状态
volatile uint8_t lastCLKState = 0;

char sprintf_tmp[16];
static u8g2_t u8g2;
uint16_t t12_now = 0, t12_pwm = 0, temp_target = DEFAULT_TARGET_TEMP;
float input, output=0;
// 屏幕刷新计时器和周期
uint32_t last_display_time = 0; // 上次屏幕刷新时间
const uint32_t DISPLAY_PERIOD_MS = 100; // 屏幕刷新周期 100ms
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_NVIC_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void){
  /* USER CODE BEGIN 1 */
  EventRecorderInitialize(EventRecordAll, 1U);
  EventRecorderStart();
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);
  LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);

  /* SysTick_IRQn interrupt configuration */
  NVIC_SetPriority(SysTick_IRQn, 3);

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */
  printf("CPU @ %d Hz\n", SystemCoreClock);
  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_ADC1_Init();
  MX_SPI1_Init();
  MX_TIM3_Init();
  MX_TIM14_Init();

  /* Initialize interrupts */
  MX_NVIC_Init();
  /* USER CODE BEGIN 2 */
  arm_pid_init_f32(&PID, 1);
  Activate_ADC();
  u8g2_Setup_ssd1306_128x64_noname_f(&u8g2, U8G2_R0, u8x8_byte_4wire_hw_spi, u8x8_stm32_gpio_and_delay);
  u8g2_InitDisplay(&u8g2);
  u8g2_SetPowerSave(&u8g2, 0);
  
  LL_TIM_EnableAllOutputs(TIM3);
  LL_TIM_CC_EnableChannel(TIM3, LL_TIM_CHANNEL_CH1);
  LL_TIM_OC_SetCompareCH1(TIM3, 0);
  LL_TIM_EnableCounter(TIM3);
  LL_TIM_EnableCounter(TIM14);
  LL_TIM_EnableIT_CC1(TIM14);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    uint32_t current_time = uWTick;
    Get_Rotary_Step_And_Clear();
    // =========================================================================
    // 状态机控制逻辑
    // =========================================================================

    switch (t12_state)
      {
        case STATE_HEATING:
            // 状态 0: 加热中，等待下一个控制周期
            if (current_time - last_time_check >= CONTROL_PERIOD_MS)
            {
                // 周期时间到，准备进入测温阶段
                LL_TIM_OC_SetCompareCH1(TIM3, 0); // 关闭加热
                last_time_check = current_time; // 重置计时器
                t12_state = STATE_PWM_OFF_WAIT_STABLE; // 切换到等待稳定状态
            }
            break;

        case STATE_PWM_OFF_WAIT_STABLE:
            // 状态 1: 关闭PWM，等待测温稳定
            if (current_time - last_time_check >= ADC_STABLE_WAIT_MS)
            {
                // 等待时间到，开始测温
                t12_state = STATE_MEASURE_TEMP; // 切换到测温状态
            }
            break;

        case STATE_MEASURE_TEMP:
            // 状态 2: 读取ADC温度
            t12_now = calculateTemp(T12_ADC_Read()); 
            //printf("t12:%d ", t12_now);
            t12_state = STATE_CALCULATE_PWM; // 切换到计算PWM状态
            break;

        case STATE_CALCULATE_PWM:
            // 状态 3: 计算新的PWM值
            {
                int16_t temp_error = (int16_t)temp_target - (int16_t)t12_now;
                if (temp_error > BANG_BANG_THRESHOLD)
                {
                  // 开关控制：全速加热
                  //t12_pwm = 1999;
                  t12_pwm = calculate_pid_pwm(temp_target, t12_now);
                }
                else
                {
                  // PID控制：精确控温
                  t12_pwm = calculate_pid_pwm(temp_target, t12_now);
                }
                SEGGER_RTT_printf(0,"%d %d %d\n", temp_target, t12_now, t12_pwm);
                //printf("err:%d pwm:%d\n", temp_error, t12_pwm);
                LL_TIM_OC_SetCompareCH1(TIM3, t12_pwm); // 应用新的加热功率
            }
            last_time_check = uWTick; // 重新开始计时，用于下一个控制周期
            t12_state = STATE_UPDATE_DISPLAY; // 切换到更新显示状态
            break;

        case STATE_UPDATE_DISPLAY:
            // 状态 4: 更新OLED显示 (可以增加一个更慢的计时器来控制显示频率)
            if (current_time - last_display_time >= DISPLAY_PERIOD_MS)
            {
                u8g2_FirstPage(&u8g2);
                do
                {
                  draw_t12_ui(&u8g2);
                } while (u8g2_NextPage(&u8g2));
                
                last_display_time = current_time; // 更新屏幕刷新时间
            }
            t12_state = STATE_HEATING; // 切换回加热等待状态，开始下一个周期
            break;

        default:
            // 错误状态处理
            t12_state = STATE_HEATING;
            break;
    }
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  /* HSI configuration and activation */
  LL_RCC_HSI_Enable();
  while(LL_RCC_HSI_IsReady() != 1)
  {
  }

  /* Set AHB prescaler*/
  LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);

  /* Sysclk activation on the HSI */
  LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
  while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI)
  {
  }

  /* Set APB1 prescaler*/
  LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);

  LL_Init1msTick(16000000);

  /* Update CMSIS variable (which can be updated also through SystemCoreClockUpdate function) */
  LL_SetSystemCoreClock(16000000);
}

/**
  * @brief NVIC Configuration.
  * @retval None
  */
static void MX_NVIC_Init(void)
{
  /* EXTI4_15_IRQn interrupt configuration */
  NVIC_SetPriority(EXTI4_15_IRQn, 2);
  NVIC_EnableIRQ(EXTI4_15_IRQn);
  /* TIM14_IRQn interrupt configuration */
  NVIC_SetPriority(TIM14_IRQn, 3);
  NVIC_EnableIRQ(TIM14_IRQn);
}

/* USER CODE BEGIN 4 */

uint16_t map(int32_t x, int32_t in_min, int32_t in_max, int32_t out_min, int32_t out_max)
{
  // 增加边界检查，防止除以零
  if (in_max == in_min) {
    return out_min;
  }
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

uint16_t calculateTemp(uint16_t RawTemp)
{
    // 如果ADC值低于第一个校准点，直接映射
    if (RawTemp <= temp_calibration_table[1].adc_val) {
        return map(RawTemp,
                   temp_calibration_table[0].adc_val,
                   temp_calibration_table[1].adc_val,
                   temp_calibration_table[0].temp_c,
                   temp_calibration_table[1].temp_c);
    }

    // 遍历校准表，找到合适的区间进行线性插值
    for (size_t i = 1; i < NUM_CALIBRATION_POINTS - 1; ++i) {
        if (RawTemp <= temp_calibration_table[i+1].adc_val) {
            return map(RawTemp,
                       temp_calibration_table[i].adc_val,
                       temp_calibration_table[i+1].adc_val,
                       temp_calibration_table[i].temp_c,
                       temp_calibration_table[i+1].temp_c);
        }
    }

    // 如果超出所有范围，则使用最后两个点进行外插
    return map(RawTemp,
               temp_calibration_table[NUM_CALIBRATION_POINTS-2].adc_val,
               temp_calibration_table[NUM_CALIBRATION_POINTS-1].adc_val,
               temp_calibration_table[NUM_CALIBRATION_POINTS-2].temp_c,
               temp_calibration_table[NUM_CALIBRATION_POINTS-1].temp_c);
}

uint16_t calculate_pid_pwm(uint16_t target, uint16_t current)
{
  int16_t error = (int16_t)target - (int16_t)current;
  int16_t output;
  output = arm_pid_f32(&PID, error);
  if (output > PID_INTEGRAL_MAX) {
    output = PID_INTEGRAL_MAX;
  } else if (output < PID_INTEGRAL_MIN) {
    output = PID_INTEGRAL_MIN;
  }
  return (uint16_t)output;
}

/**
 * @brief 获取编码器步数变化值并清零
 * @return 编码器步数变化值（>0 为正转，<0 为反转，=0 为未动）
 */
int16_t Get_Rotary_Step_And_Clear(void)
{
    int16_t step = 0;
    step = rotaryCount;
    if(step > 0)
    {
      temp_target += 5;
    } 
    else if(step < 0)
    {
      temp_target -= 5;
    }
    rotaryCount = 0; // 清除计数值
    return step;
}

/**
 * @brief 绘制T12烙铁控制器的UI界面 (适配 128x64 分辨率)
 */
void draw_t12_ui(u8g2_t *u8g2)
{
    u8g2_SetFontMode(u8g2, 1);
    u8g2_SetFontDirection(u8g2, 0);
    u8g2_SetFont(u8g2, u8g2_font_9x15_tr);
    sprintf(sprintf_tmp, "%d %d", Vref_Read(), Vin_Read());
    u8g2_DrawStr(u8g2, 0, 10, sprintf_tmp);
    sprintf(sprintf_tmp, "tmp:%d C", Temp_ADC_Read());
    u8g2_DrawStr(u8g2, 0, 22, sprintf_tmp);
    sprintf(sprintf_tmp, "%3d,%3d,%d%%", temp_target, t12_now, t12_pwm/20);
    u8g2_DrawStr(u8g2, 0, 34, sprintf_tmp);
}

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
